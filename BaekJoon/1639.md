# [백준] 1639-행운의 티켓

[문제](https://www.acmicpc.net/problem/1639)는 다음과 같다.  

솔직히 온전히 내 힘으로 풀지 못했다.  
우선 문제 파악은 쉬웠다. 랜덤 문자열의 티켓을 받고, 왼쪽 N자리와 오른쪽 N자리의 합이 같은(즉, 행운의 티켓) 숫자 길이의 최댓값을 찾는 문제다.  

그러니까 조건을 만족하는 1. 문자열을 찾고, 2. 그 길이를 구하면 된다.  
그렇지만 문자열의 위치가 정확히 중심을 기준으로 대칭이 아니라, 그 문자열 어디든 위치할 수 있다는게 문제였다.  

그래서 처음에는 나는 입력받은 문자열의 길이로, 가질 수 있는 최대 행운의 티켓 문자열 길이를 찾고, 그 길이대로 문자열을 자르려고 했다.  
그 크기의 배열로 나누고 이웃되는 배열의 합끼리 비교를 하면 되니까.  
이렇게 하려고 하니까 for 구문이 3번 이상 중첩되는 등의 현상이 발생했다.  

그리고 나눗셈으로 배열의 개수를 구하려고 했는데 이게 나중에는 말이 안되는 풀이라는 걸 깨달았다.  
예를 들어 최대 문자열 길이가 2라고 했을 때 8/2==4 니까 4개 배열이 나오고 그것끼리만 비교하면 된다고 생각했는데,  
start index가 0에서 1이 되는 순간은 3개 배열이 되고, 1에서 2가 되면 또 3개 배열이 되고 아무튼 생각했던 것과는 달랐다.  

그래서 풀이법을 검색해서 해석하기 시작했다. 초반이니까 이걸로도 공부가 될 것이라고 생각한다.  
풀이를 이해하는 것 조차도 어려웠으니까ㅋㅋㅋㅋ  
근데 다 푼 지금은 굉장히 쉬운 문제인 것 같다.  

요는 아래와 같다.  
1. 우선 입력받은 문자열이 홀수인지 짝수인지를 파악해야 한다. (홀짝여부에 따라 마지막 index 값이 달라지기 때문이다.)  
2-1. 짝수일 때 2\*N 길이를 만들기 위해서는 그냥 문자열 길이가 end index 이면 된다. (for 구문에서 < end 하면 되니까)  
2-2. 홀수일 때 2\*N 길이를 만들기 위해서는 end index 문자열 길이-1 이어야 한다. 그래야 그 전(end-1)까지의 총 길이가 2\*N이 되니까.  
3. 그리고 start=0 부터 시작한다. 그러니까 가질 수 있는 최대 문자열 길이(ex.8)부터 살펴보는 것이다. mid = (start+end)/2 **그럼 다음 문자열 길이는 어떻게 살펴봐야할까??**  
4. 다음 loop에서 start=0으로 같지만 end를 -2씩 줄여나간다. (2\*N을 맞춰서 시작했으니까 그 다음 2*N은 -2를 해야 만날 수 있음) ex. 여기서 6 문자열 길이를 찾는 것이다. 8 길이는 3에서 다 살펴봤으니까.  
5. 그리고 start와 end를 하나씩 늘려가가면서 다음 index부터 시작되는 2\*N(ex.6) 을 살펴본다.  

그러니까 이 풀이의 요지는  
* 문자열 길이를 하나를 다 찾고, end를 -2해서 다음 문자열 길이를 start와 end를 둘다 +1 해가면서 살펴보는 것  
이라고 할 수 있다. end(즉, 인덱스) 설정도 중요하지만 얘는 이것만 알았으면 어떻게든 가능했을 것 같다. 그리고 mid는 start, end의 절반으로 구할 수 있으니.  

암튼 다음에는 내 힘으로 꼭 풀고 싶다.  
